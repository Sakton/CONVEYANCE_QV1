
/*
NO ACTION
Выдать ошибку, показывающую, что при удалении или изменении записи 
произойдёт нарушение ограничения внешнего ключа. Для отложенных ограничений 
ошибка произойдёт в момент проверки ограничения, если строки, ссылающиеся на эту запись, 
по-прежнему будут существовать. Этот вариант действия подразумевается по умолчанию.

RESTRICT
Выдать ошибку, показывающую, что при удалении или изменении записи 
произойдёт нарушение ограничения внешнего ключа. Этот вариант подобен NO ACTION, но эта проверка будет неоткладываемой.

CASCADE
Удалить все строки, ссылающиеся на удаляемую запись, либо поменять 
значения в ссылающихся столбцах на новые значения во внешних столбцах, в соответствии с операцией.

SET NULL
Установить ссылающиеся столбцы равными NULL.

SET DEFAULT
Установить в ссылающихся столбцах значения по умолчанию. 
(Если эти значения не равны NULL, во внешней таблице должна быть строка, 
соответствующая набору значений по умолчанию; в противном случае операция завершится ошибкой.)
*/

-- CREATE DATABASE demo_coveyance_db;

/*
--VATS
CREATE TABLE vats (
	vat_id SERIAL UNIQUE,
	vat_stavka decimal(4, 2) NOT NULL UNIQUE,
	CONSTRAINT vats_valid CHECK ( vat_stavka > 0 AND vat_stavka < 100 ),
	PRIMARY KEY ( vat_id )
);

CREATE TABLE vatnames (
	vatname_id SERIAL UNIQUE,
	vatname_name VARCHAR( 10 ),
	PRIMARY KEY ( vatname_id )
);

--CITIES
CREATE TABLE сities (
	city_id SERIAL UNIQUE,
	city_name VARCHAR( 256 ) NOT NULL UNIQUE,
	country_id INT,
	PRIMARY KEY ( city_id )
);

-- STRDETS

CREATE TABLE streets (
	street_id SERIAL UNIQUE,
	street_name varchar ( 256 ) NOT NULL UNIQUE
);



CREATE TABLE countrys (
	country_id SERIAL UNIQUE,
	vat_id INT NOT NULL,
	vatname_id INT NOT NULL,
	country_name VARCHAR(256) NOT NULL UNIQUE,
	country_abbreviated_2 VARCHAR(4) NOT NULL UNIQUE,
	country_abbreviated_3 VARCHAR(4) NOT NULL UNIQUE,
	country_icon VARCHAR(256),
	PRIMARY KEY ( country_id ),
	FOREIGN KEY ( vat_id ) REFERENCES vats ( vat_id )
		ON UPDATE SET NULL ON DELETE SET NULL,
	FOREIGN KEY ( vatname_id ) REFERENCES vatnames ( vatname_id )
		ON UPDATE SET NULL ON DELETE SET NULL
);


CREATE TABLE adress (
	adres_id SERIAL UNIQUE,
	country_id INT,
	city_id INT,
	street_id INT,
	adres_type Type_Adress, -- тип адреса (физический, юридический)
	PRIMARY KEY ( adres_id ),
	FOREIGN KEY ( country_id ) REFERENCES countrys ( country_id )
		ON DELETE SET NULL,
	FOREIGN KEY ( city_id ) REFERENCES cities ( city_id )
		ON DELETE SET NULL,
	FOREIGN KEY ( street_id ) REFERENCES streets ( street_id )
		ON DELETE SET NULL,
	CHECK ( adres_type IN ( 'FACT', 'LEGAL') )
);


CREATE FUNCTION id_country ( cntr VARCHAR ) RETURNS INTEGER
AS $$ SELECT country_id FROM countrys WHERE country_name = cntr $$ LANGUAGE SQL;


	
CREATE FUNCTION id_city ( ct VARCHAR ) RETURNS INT 
AS $$ SELECT city_id FROM cities WHERE city_name = ct $$ LANGUAGE SQL;


CREATE FUNCTION id_street( st VARCHAR ) RETURNS INT 
AS $$ SELECT street_id FROM streets WHERE street_name = st $$ LANGUAGE SQL;


CREATE OR REPLACE PROCEDURE insert_adress ( cntr VARCHAR, ct VARCHAR, strt VARCHAR, idx VARCHAR, type_adress VARCHAR )
LANGUAGE SQL
AS $$
	INSERT INTO adress ( country_id, city_id, street_id, adres_index, adres_type )
	VALUES (  ( SELECT id_country( cntr ) ), ( SELECT id_city( ct ) ), ( SELECT id_street( strt ) ), idx, type_adress );
$$;



CREATE OR REPLACE FUNCTION id_vatnames ( nm VARCHAR ) RETURNS INT AS
' SELECT vatname_id FROM vatnames WHERE vatname_name = nm '
LANGUAGE SQL;

*/

CREATE OR REPLACE FUNCTION get_id_country ( nm VARCHAR ) RETURNS INT AS
 'SELECT country_id FROM countrys WHERE country_name = nm'
LANGUAGE SQL;

CREATE OR REPLACE FUNCTION insertOrIgnoreStreet( strt VARCHAR ) RETURNS BOOL AS
$$
BEGIN
	IF EXISTS(  SELECT street_id FROM streets WHERE street_name = strt ) IS NULL
		THEN  INSERT INTO streets ( street_name ) VALUES ( strt );
			RETURN TRUE;
		ELSE 
			RETURN FALSE;
	END IF;
END;
$$
LANGUAGE plpgsql;































